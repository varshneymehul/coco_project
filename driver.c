#include "lexer.h"
#include "parser.h"
#include <time.h>

void printFileConsolidated(const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        printf("Error opening file %s\n", filename);
        return;
    }
    char c;
    while ((c = fgetc(fp)) != EOF) {
        putchar(c);
    }
    fclose(fp);
    printf("\n");
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: ./stage1exe testcaseFile.txt parsetreeOutFile.txt\n");
        return 1;
    }

    printf("Implementation Status:\n");
    printf("- Lexical and syntax analysis modules implemented.\n");
    printf("- FIRST and FOLLOW set automated completely.\n");
    printf("- Predictive LL(1) Parse Table populated systematically.\n");
    printf("- Parse Tree built robustly using Inorder Traversal.\n\n");

    int option;
    do {
        printf("--------------- MENU ---------------\n");
        printf("0: Exit\n");
        printf("1: Remove comments\n");
        printf("2: Print Token List\n");
        printf("3: Parse and Print Tree\n");
        printf("4: Print Time Taken\n");
        printf("Choose an option: ");
        if (scanf("%d", &option) != 1) {
            printf("Invalid input. Exiting.\n");
            break;
        }

        switch (option) {
            case 0:
                printf("Exiting compiler...\n");
                break;
            case 1:
                printf("\n--- Code without comments ---\n");
                removeComments(argv[1], "cleanFile.txt");
                printFileConsolidated("cleanFile.txt");
                break;
            case 2: {
                printf("\n--- Tokens generated by Lexer ---\n");
                FILE *fp = fopen(argv[1], "r");
                if (!fp) {
                    printf("Could not open source code file.\n");
                    break;
                }
                twinBuffer B = initBuffer(fp);
                tokenInfo t;
                while (1) {
                    t = getNextToken(B);
                    if (t.type == TK_EOF) break;
                    if (t.type == TK_ERROR) continue; // Already prints line
                    
                    printf("Line No: %-5d | Token: %-20s | Lexeme: %s\n", 
                           t.lineNo, getTokenName(t.type), t.lexeme);
                }
                closeBuffer(B);
                fclose(fp);
                break;
            }
            case 3: {
                // Parse & Print Tree
                grammar G;
                FirstAndFollowSets(&G);
                
                table T;
                FirstAndFollow F; // dummy for signature wrapper
                createParseTable(F, &T, &G);
                
                parseTree PT = parseInputSourceCode(argv[1], T, G);
                if (PT != NULL) {
                    printParseTree(PT, argv[2]);
                    freeParseTree(PT);
                    printf("Parse tree successfully saved to %s\n", argv[2]);
                }
                break;
            }
            case 4: {
                clock_t start_time, end_time;
                double total_CPU_time, total_CPU_time_in_seconds;

                start_time = clock();

                // Run Lexer and Parser logic
                grammar G;
                FirstAndFollowSets(&G);
                table T;
                FirstAndFollow F;
                createParseTable(F, &T, &G);
                parseTree PT = parseInputSourceCode(argv[1], T, G);
                if (PT) freeParseTree(PT);

                end_time = clock();
                
                total_CPU_time = (double)(end_time - start_time);
                total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

                printf("Total CPU time: %f ticks\n", total_CPU_time);
                printf("Total CPU time in seconds: %f seconds\n", total_CPU_time_in_seconds);
                break;
            }
            default:
                printf("Invalid option. Please choose between 0 and 4.\n");
                break;
        }
        printf("\n");
    } while (option != 0);

    return 0;
}
